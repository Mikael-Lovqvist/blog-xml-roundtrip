from t8_types import tokenizer, rules, Path, format_xml, XML_TOKEN, dump, pretty_dump_xml
#This is continuation from t8 but here we will apply some templates.

t = tokenizer(rules.main)
t.process(Path('data/template2.xml').read_text())

[doc] = t.element.pop_all() #make sure w get exactly one thing

MISS = type('MISS', (), {})

class template_processor:
	def __init__(self, parent=None, placeholder_prefix=None, template_prefix=None, locals=None, placeholder_fallback=None):
		self.parent = parent
		self.locals = locals
		self.placeholder_fallback = placeholder_fallback

		#Note - set placeholder_prefix to False if you want to explicitly not use it
		pending_placeholder_prefix = placeholder_prefix
		if placeholder_prefix is None:
			if parent:
				pending_placeholder_prefix = parent.placeholder_prefix

		self.placeholder_prefix = pending_placeholder_prefix

		#Note - set template_prefix to False if you want to explicitly not use it
		pending_template_prefix = template_prefix
		if template_prefix is None:
			if parent:
				pending_template_prefix = parent.template_prefix

		self.template_prefix = pending_template_prefix

	def get_placeholder_value(self, id):
		value = self.get_placeholder(id)
		assert isinstance(value, str), f'Placeholder {id!r} expected to be str, got: {value!r}'
		return value

	def get_placeholder(self, id):
		if self.locals:
			if (l := self.locals.get(id, MISS)) is not MISS:
				if callable(l):
					return l(self, id)
				else:
					return l

		if self.parent:
			return self.parent.get_placeholder(id)

		if self.placeholder_fallback:
			return self.placeholder_fallback(self, id)

		raise Exception(f'Could not resolve place holder {id!r}')


	def __call__(self, item):	#TODO - this should probably be part of the context
		if isinstance(item, XML_TOKEN.element):

			if self.placeholder_prefix and self.placeholder_prefix == item.prefix:
				return self.get_placeholder(item.tag)
			else:
				return XML_TOKEN.element(
					item.prefix,
					item.tag,
					tuple(item.process_attributes(self)),
					tuple(item.process_children(self))
				)
		if isinstance(item, XML_TOKEN.meta_element):
			return item	#No change for now

		elif isinstance(item, XML_TOKEN.data):
			return item	#No change
		elif isinstance(item, XML_TOKEN.attribute):
			if isinstance(item.value, XML_TOKEN.reference):
				return XML_TOKEN.attribute(
					item.prefix,
					item.name,
					self.get_placeholder_value(item.value.id),
				)
			else:
				return item

		elif isinstance(item, XML_TOKEN.document):	# We will check for templates in a document if we have template_prefix
			if self.template_prefix:
				return type('templates', (), {t.tag: template(self, t.tag, t) for t in doc.iter_children(instance_check=XML_TOKEN.element) if t.prefix == self.template_prefix})
			else:
				return item
		else:
			raise TypeError(item)

	def stack(self, locals):
		return template_processor(parent=self, locals=locals)


class template:
	def __init__(self, context, id, element):
		self.context = context
		self.id = id
		self.element = element

	def __call__(self, **context_updates):
		return XML_TOKEN.fragment(tuple(self.element.process_children(self.context.stack(context_updates))))




# def iter_templates_by_prefix(document, context, prefix='TEMPLATE'):
# 	for node in document.iter_children(instance_check=XML_TOKEN.element):
# 		if node.prefix == prefix:
# 			yield template(context, node.tag, node)


context = template_processor(
	placeholder_prefix = 'PLACEHOLDER',
	template_prefix = 'TEMPLATE',
	placeholder_fallback = lambda ctx, id: XML_TOKEN.comment(f'MISSING PLACEHOLDER: {id}'),
	locals = dict(
		graph_id = 'G',
	),
)

TPL = context(doc)

# test_frag = XML_TOKEN.fragment((
# 	XML_TOKEN.comment('COM!'),
# 	XML_TOKEN.data('DATA!'),
# 	XML_TOKEN.comment('COM!'),
# ))



#<key attr.name="Description" attr.type="string" for="graph" id="d0"/>
key_definitions = XML_TOKEN.fragment((
	TPL.key_def(name='Description', type='string', for_='graph', id='d0'),
))

r = TPL.graph(
	comment = XML_TOKEN.comment('Generated by t9.py'),
	graph = TPL.graph_def(
		key_ref = XML_TOKEN.fragment((
			XML_TOKEN.element(None, 'data', (XML_TOKEN.attribute(None, 'key', 'd0'),), ()),
		)),
	),
	key_definitions = key_definitions,
)


pretty_dump_xml(format_xml(r))